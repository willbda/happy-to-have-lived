//
// ActionRepository_v3.swift
// Written by Claude Code on 2025-11-16
//
// PURPOSE:
// Repository for Action entities using canonical ActionData type.
// Refactored to leverage BaseRepository infrastructure with single generic parameter.
//
// DESIGN DECISIONS:
// - Extends BaseRepository<ActionData> (no separate export type)
// - Uses JSON aggregation for measurements + goal contributions (1:many relationships)
// - Inherits: error mapping, read/write wrappers, date filtering, pagination
// - Adds entity-specific: relationship queries, aggregations, compound checks
//
// INTERACTION WITH CORE:
// - BaseRepository: Provides read/write wrappers, error mapping, pagination helpers
// - QueryStrategies: Uses JSONAggregationStrategy for complex relationships
// - ExportSupport: Date filtering via buildDateFilter() helper
// - RepositoryProtocols: Conforms to Repository protocol (single DataType)
//

import Foundation
import Models
import SQLiteData
import GRDB

/// Repository for managing Action entities with measurements and goal contributions
///
/// **Architecture Pattern**:
/// ```
/// ActionRepository_v3 → BaseRepository<ActionData> → Repository protocol
///                    ↓
///         JSONAggregationStrategy (for measurements + contributions)
/// ```
///
/// **What BaseRepository Provides**:
/// - ✅ Error mapping (mapDatabaseError)
/// - ✅ Read/write wrappers with automatic error handling
/// - ✅ Date filtering helpers (buildDateFilter)
/// - ✅ Pagination (fetch(limit:offset:), fetchRecent(limit:))
///
/// **What This Repository Adds**:
/// - Entity-specific queries (fetchByGoal, fetchByMeasure)
/// - Aggregations (totalByMeasure, countByGoal)
/// - Compound uniqueness checks (exists(title:on:))
/// - JSON aggregation assembly (measurements + contributions → ActionData)
///
public final class ActionRepository_v3: BaseRepository<ActionData> {
    // MARK: - Required Overrides

    /// Fetch all actions with measurements and goal contributions
    ///
    /// **Implementation Strategy**: JSON Aggregation
    /// - Single SQL query with nested SELECT for relationships
    /// - Avoids N+1 problem (was 763 queries, now 1 query)
    /// - Returns ActionData (canonical type, not ActionWithDetails)
    ///
    /// **SQL Pattern**:
    /// ```sql
    /// SELECT a.*,
    ///   COALESCE((SELECT json_group_array(...) FROM measuredActions WHERE actionId = a.id), '[]') as measurementsJson,
    ///   COALESCE((SELECT json_group_array(...) FROM actionGoalContributions WHERE actionId = a.id), '[]') as contributionsJson
    /// FROM actions a
    /// ORDER BY logTime DESC
    /// ```
    ///
    /// TODO: Implement JSON aggregation query returning [ActionData]
    public override func fetchAll() async throws -> [ActionData] {
        fatalError("TODO: Implement JSON aggregation query")
        // try await read { db in
        //     let rows = try ActionQueryRow.fetchAll(db, sql: jsonAggregationSQL)
        //     return try rows.map { row in
        //         try assembleActionData(from: row)
        //     }
        // }
    }

    /// Check if action exists by ID
    ///
    /// **Implementation**: Simple SELECT COUNT query
    /// Uses inherited `read` wrapper for automatic error mapping.
    ///
    /// TODO: Implement using #sql or raw SQL
    public override func exists(_ id: UUID) async throws -> Bool {
        fatalError("TODO: Implement exists check")
        // try await read { db in
        //     try Action.filter(id: id).fetchCount(db) > 0
        // }
    }

    /// Fetch actions with optional date filtering (for export)
    ///
    /// **Implementation**: Same as fetchAll() + WHERE clause
    /// Uses inherited `buildDateFilter` helper for SQL generation.
    ///
    /// **Pattern**:
    /// ```swift
    /// let (whereClause, args) = buildDateFilter(from: startDate, to: endDate, dateColumn: "logTime")
    /// // Add whereClause to JSON aggregation SQL
    /// ```
    ///
    /// TODO: Implement with date filter injection
    public override func fetchForExport(from startDate: Date?, to endDate: Date?) async throws -> [ActionData] {
        fatalError("TODO: Implement export with date filter")
        // Same JSON aggregation SQL as fetchAll(), but with WHERE clause inserted
    }

    // MARK: - Pagination Overrides (Optional - for SQL-level optimization)

    /// Fetch paginated actions (override for SQL LIMIT/OFFSET instead of in-memory slicing)
    ///
    /// **Why Override**: Base implementation fetches all then slices in memory (inefficient)
    /// **Optimization**: Add LIMIT/OFFSET to SQL query for database-level pagination
    ///
    /// TODO: Implement SQL-level pagination
    public override func fetch(limit: Int, offset: Int = 0) async throws -> [ActionData] {
        fatalError("TODO: Add LIMIT/OFFSET to JSON aggregation SQL")
    }

    /// Fetch most recent actions (override for SQL ORDER BY + LIMIT)
    ///
    /// **Why Override**: Base implementation can't guarantee sort order
    /// **Optimization**: Add ORDER BY logTime DESC LIMIT ? to SQL
    ///
    /// TODO: Implement with SQL sorting
    public override func fetchRecent(limit: Int) async throws -> [ActionData] {
        fatalError("TODO: Add ORDER BY logTime DESC LIMIT ? to SQL")
    }

    // MARK: - Entity-Specific Queries (Relationship Filtering)

    /// Fetch actions that contribute to a specific goal
    ///
    /// **Use Case**: "Show all workouts contributing to my marathon goal"
    /// **Implementation**: JOIN with actionGoalContributions WHERE goalId = ?
    ///
    /// **Note**: This is entity-specific (NOT in BaseRepository)
    /// Different entities have different relationships.
    ///
    /// TODO: Implement goal filtering
    public func fetchByGoal(goalId: UUID) async throws -> [ActionData] {
        fatalError("TODO: Implement fetchByGoal with JOIN")
    }

    /// Fetch actions measured with a specific measure
    ///
    /// **Use Case**: "Show all actions tracked with 'distance (miles)' measure"
    /// **Implementation**: JOIN with measuredActions WHERE measureId = ?
    ///
    /// TODO: Implement measure filtering
    public func fetchByMeasure(measureId: UUID) async throws -> [ActionData] {
        fatalError("TODO: Implement fetchByMeasure with JOIN")
    }

    // MARK: - Aggregations (Analytics Queries)

    /// Calculate total measured value for a specific measure in date range
    ///
    /// **Use Case**: "Total miles run in last 30 days"
    /// **Implementation**: SUM(value) FROM measuredActions WHERE measureId = ? AND date BETWEEN ? AND ?
    ///
    /// **Pattern**: Could be abstracted to BaseRepository if common across entities
    /// For now, keep entity-specific.
    ///
    /// TODO: Implement aggregation query
    public func totalByMeasure(_ measureId: UUID, in dateRange: ClosedRange<Date>) async throws -> Double {
        fatalError("TODO: Implement SUM aggregation with date filter")
    }

    /// Count actions contributing to a specific goal
    ///
    /// **Use Case**: "How many workouts contributed to this goal?"
    /// **Implementation**: COUNT(*) FROM actionGoalContributions WHERE goalId = ?
    ///
    /// TODO: Implement count query
    public func countByGoal(_ goalId: UUID) async throws -> Int {
        fatalError("TODO: Implement COUNT with goal filter")
    }

    // MARK: - Compound Uniqueness Checks

    /// Check if action with title exists on specific date
    ///
    /// **Use Case**: Prevent duplicate "Morning run" on same day
    /// **Implementation**: SELECT COUNT WHERE title = ? AND DATE(logTime) = DATE(?)
    ///
    /// **Note**: Compound checks are entity-specific (NOT in BaseRepository)
    /// PersonalValue checks title uniqueness, Action checks title+date, etc.
    ///
    /// TODO: Implement compound check
    public func exists(title: String, on date: Date) async throws -> Bool {
        fatalError("TODO: Implement compound uniqueness check")
    }

    // MARK: - Private Helpers (JSON Aggregation Assembly)

    /// Assemble ActionData from JSON-aggregated query row
    ///
    /// **Pattern**: Parse measurementsJson and contributionsJson arrays
    /// Construct ActionData with nested Measurement and Contribution structs.
    ///
    /// **Reference**: See ActionData.swift for struct definitions
    ///
    /// TODO: Implement JSON parsing and assembly
    private func assembleActionData(from row: ActionQueryRow) throws -> ActionData {
        fatalError("TODO: Parse JSON arrays and assemble ActionData")
    }

    // TODO: Define ActionQueryRow struct (mirrors SQL query result)
    private struct ActionQueryRow: Decodable, FetchableRecord, Sendable {
        // Action fields
        let id: UUID
        let title: String
        let detailedDescription: String?
        let freeformNotes: String?
        let logTime: Date
        let durationMinutes: Double?
        let startTime: Date?

        // JSON aggregated relationships
        let measurementsJson: String  // JSON array of measurements
        let contributionsJson: String // JSON array of goal contributions
    }
}

// MARK: - Sendable Conformance

// ActionRepository_v3 is Sendable because:
// - Inherits from BaseRepository (already Sendable)
// - No additional mutable state
// - Safe to pass between actor boundaries
extension ActionRepository_v3: @unchecked Sendable {}

// =============================================================================
// IMPLEMENTATION CHECKLIST
// =============================================================================
//
// [ ] Define ActionQueryRow struct with JSON columns
// [ ] Write JSON aggregation SQL (measurements + contributions)
// [ ] Implement assembleActionData(from:) - parse JSON arrays
// [ ] Override fetchAll() - execute SQL, map rows to ActionData
// [ ] Override exists(_:) - simple ID check
// [ ] Override fetchForExport(from:to:) - add WHERE clause to SQL
// [ ] Override fetch(limit:offset:) - add LIMIT/OFFSET to SQL (optional but recommended)
// [ ] Override fetchRecent(limit:) - add ORDER BY + LIMIT to SQL (optional but recommended)
// [ ] Implement fetchByGoal(_:) - JOIN with actionGoalContributions
// [ ] Implement fetchByMeasure(_:) - JOIN with measuredActions
// [ ] Implement totalByMeasure(_:in:) - SUM aggregation
// [ ] Implement countByGoal(_:) - COUNT query
// [ ] Implement exists(title:on:) - compound uniqueness check
// [ ] Test with ActionData.asDetails for backward compatibility
//
// =============================================================================
