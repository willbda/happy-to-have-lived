//
// GoalRepository_v3.swift
// Written by Claude Code on 2025-11-16
//
// PURPOSE:
// Repository for Goal entities using canonical GoalData type.
// Most complex repository - flattens Goal+Expectation, loads 3 relationship types.
//
// DESIGN DECISIONS:
// - Extends BaseRepository<GoalData> (no separate export type)
// - Uses JSON aggregation for measures + values + terms (3 x 1:many relationships)
// - Flattens Goal + Expectation fields into single GoalData structure
// - Inherits: error mapping, read/write wrappers, date filtering, pagination
// - Adds entity-specific: multi-table joins, aggregations, compound checks
//
// INTERACTION WITH CORE:
// - BaseRepository: Provides read/write wrappers, error mapping, pagination helpers
// - QueryStrategies: Uses JSONAggregationStrategy (complex multi-table joins)
// - ExportSupport: Date filtering via buildDateFilter() helper
// - RepositoryProtocols: Conforms to Repository protocol (single DataType)
//

import Foundation
import Models
import SQLiteData
import GRDB

/// Repository for managing Goal entities with expectations, measures, values, and terms
///
/// **Architecture Pattern**:
/// ```
/// GoalRepository_v3 → BaseRepository<GoalData> → Repository protocol
///                   ↓
///        JSONAggregationStrategy (for measures + values + terms)
/// ```
///
/// **Complexity Drivers**:
/// 1. **Flattened Schema**: Goal + Expectation fields merged into GoalData
/// 2. **Three Relationships**: MeasureTargets, ValueAlignments, TermAssignments
/// 3. **Nested Structures**: Each relationship has multiple fields (not just IDs)
///
/// **What BaseRepository Provides**:
/// - ✅ Error mapping (mapDatabaseError)
/// - ✅ Read/write wrappers with automatic error handling
/// - ✅ Date filtering helpers (buildDateFilter)
/// - ✅ Pagination (fetch(limit:offset:), fetchRecent(limit:))
///
/// **What This Repository Adds**:
/// - Multi-table joins (goals + expectations + measures + values + terms)
/// - JSON aggregation for 3 relationship types
/// - Title uniqueness checks (compound: title + expectation)
/// - Value alignment filtering (goals aligned with specific value)
/// - Term assignment filtering (goals in specific term)
/// - Progress aggregations (total contributions from actions)
///
public final class GoalRepository_v3: BaseRepository<GoalData> {
    // MARK: - Required Overrides

    /// Fetch all goals with expectations, measures, values, and terms
    ///
    /// **Implementation Strategy**: Multi-table JSON Aggregation
    /// - Join goals → expectations (1:1, required)
    /// - Join expectationMeasures → measures (1:many)
    /// - Join goalRelevances → personalValues (1:many)
    /// - Join termGoalAssignments → goalTerms (1:many, optional)
    /// - Use json_group_array for all 1:many relationships
    ///
    /// **SQL Pattern**:
    /// ```sql
    /// SELECT
    ///   g.*,                    -- Goal fields
    ///   e.*,                    -- Expectation fields (flattened)
    ///   COALESCE((SELECT json_group_array(json_object(
    ///     'measureId', em.measureId,
    ///     'measureTitle', m.title,
    ///     'targetValue', em.targetValue,
    ///     'unit', m.unit
    ///   )) FROM expectationMeasures em
    ///   JOIN measures m ON em.measureId = m.id
    ///   WHERE em.expectationId = e.id), '[]') as measuresJson,
    ///   COALESCE((SELECT json_group_array(...) FROM goalRelevances ...), '[]') as valuesJson,
    ///   COALESCE((SELECT json_group_array(...) FROM termGoalAssignments ...), '[]') as termsJson
    /// FROM goals g
    /// JOIN expectations e ON g.expectationId = e.id
    /// ORDER BY e.expectationImportance DESC, e.expectationUrgency DESC
    /// ```
    ///
    /// **Complexity Note**: This is the most complex query in the repository layer.
    /// Careful testing required for JSON parsing and assembly.
    ///
    /// TODO: Implement multi-table JSON aggregation query
    public override func fetchAll() async throws -> [GoalData] {
        fatalError("TODO: Implement multi-table JSON aggregation")
        // try await read { db in
        //     let rows = try GoalQueryRow.fetchAll(db, sql: complexJoinSQL)
        //     return try rows.map { row in
        //         try assembleGoalData(from: row)
        //     }
        // }
    }

    /// Check if goal exists by ID
    ///
    /// **Implementation**: Simple SELECT COUNT query on goals table
    /// Uses inherited `read` wrapper for automatic error mapping.
    ///
    /// TODO: Implement using #sql or raw SQL
    public override func exists(_ id: UUID) async throws -> Bool {
        fatalError("TODO: Implement exists check")
        // try await read { db in
        //     try Goal.filter(id: id).fetchCount(db) > 0
        // }
    }

    /// Fetch goals with optional date filtering (for export)
    ///
    /// **Implementation**: Same multi-table join + WHERE clause
    /// Filter on expectations.logTime (not goals.startDate)
    ///
    /// **Note**: Goals don't have logTime, but their Expectation does
    /// Use buildDateFilter with dateColumn: "e.logTime"
    ///
    /// TODO: Implement export with date filter on expectation logTime
    public override func fetchForExport(from startDate: Date?, to endDate: Date?) async throws -> [GoalData] {
        fatalError("TODO: Implement export with WHERE e.logTime BETWEEN ? AND ?")
    }

    // MARK: - Pagination Overrides (Recommended for complex queries)

    /// Fetch paginated goals (override for SQL LIMIT/OFFSET)
    ///
    /// **Why Override**: Complex JSON aggregation is expensive
    /// LIMIT/OFFSET at SQL level reduces processing significantly
    ///
    /// TODO: Implement SQL-level pagination
    public override func fetch(limit: Int, offset: Int = 0) async throws -> [GoalData] {
        fatalError("TODO: Add LIMIT/OFFSET to multi-table join")
    }

    /// Fetch most recent goals (override for SQL ORDER BY + LIMIT)
    ///
    /// **Note**: "Recent" = expectation.logTime DESC (not goal.startDate)
    /// Shows when goal was created, not when it starts
    ///
    /// TODO: Implement with SQL sorting on expectation.logTime
    public override func fetchRecent(limit: Int) async throws -> [GoalData] {
        fatalError("TODO: Add ORDER BY e.logTime DESC LIMIT ?")
    }

    // MARK: - Entity-Specific Queries (Relationship Filtering)

    /// Fetch goals aligned with a specific personal value
    ///
    /// **Use Case**: "Show all goals serving my 'Health' value"
    /// **Implementation**: JOIN with goalRelevances WHERE valueId = ?
    ///
    /// **Note**: This is the inverse of PersonalValueData.alignedGoalIds
    ///
    /// TODO: Implement value filtering
    public func fetchAlignedWith(valueId: UUID) async throws -> [GoalData] {
        fatalError("TODO: Implement JOIN with goalRelevances")
    }

    /// Fetch goals assigned to a specific term
    ///
    /// **Use Case**: "Show all goals for Term 5 (current term)"
    /// **Implementation**: JOIN with termGoalAssignments WHERE termId = ?
    ///
    /// TODO: Implement term filtering
    public func fetchInTerm(termId: UUID) async throws -> [GoalData] {
        fatalError("TODO: Implement JOIN with termGoalAssignments")
    }

    /// Fetch goals measured with a specific measure
    ///
    /// **Use Case**: "Show all goals tracked with 'weight (lbs)' measure"
    /// **Implementation**: JOIN expectationMeasures WHERE measureId = ?
    ///
    /// TODO: Implement measure filtering
    public func fetchByMeasure(measureId: UUID) async throws -> [GoalData] {
        fatalError("TODO: Implement JOIN with expectationMeasures")
    }

    /// Fetch active goals (startDate <= today, targetDate >= today)
    ///
    /// **Use Case**: "What goals am I working on right now?"
    /// **Implementation**: WHERE startDate <= ? AND targetDate >= ?
    ///
    /// TODO: Implement active date range filtering
    public func fetchActive(asOf date: Date = Date()) async throws -> [GoalData] {
        fatalError("TODO: Implement date range filtering")
    }

    /// Fetch goals by importance/urgency quadrant
    ///
    /// **Use Case**: "Show high importance + high urgency goals"
    /// **Implementation**: WHERE expectationImportance >= ? AND expectationUrgency >= ?
    ///
    /// **Eisenhower Matrix**: importance x urgency = priority quadrants
    ///
    /// TODO: Implement importance/urgency filtering
    public func fetchByPriority(
        minimumImportance: Int,
        minimumUrgency: Int
    ) async throws -> [GoalData] {
        fatalError("TODO: Implement priority quadrant filtering")
    }

    // MARK: - Aggregations (Progress Tracking)

    /// Calculate total progress for a goal (sum of action contributions)
    ///
    /// **Use Case**: "How much progress have I made toward this goal?"
    /// **Implementation**: SUM(contributionAmount) FROM actionGoalContributions WHERE goalId = ?
    ///
    /// **Note**: This crosses repository boundaries (Goal + Action)
    /// Consider if this belongs in a separate AnalyticsService
    ///
    /// TODO: Implement progress aggregation
    public func totalProgress(for goalId: UUID) async throws -> Double {
        fatalError("TODO: Implement SUM of action contributions")
    }

    /// Count actions contributing to a goal
    ///
    /// **Use Case**: "How many workouts have contributed to this goal?"
    /// **Implementation**: COUNT(*) FROM actionGoalContributions WHERE goalId = ?
    ///
    /// TODO: Implement contribution count
    public func countContributions(for goalId: UUID) async throws -> Int {
        fatalError("TODO: Implement COUNT of contributions")
    }

    // MARK: - Compound Uniqueness Checks

    /// Check if goal with title exists (via expectation title)
    ///
    /// **Use Case**: Prevent duplicate "Run a marathon" goals
    /// **Implementation**: JOIN expectations, check LOWER(e.title) = LOWER(?)
    ///
    /// **Note**: Title is stored in expectations table, not goals table
    ///
    /// TODO: Implement title uniqueness check via expectation
    public func exists(title: String) async throws -> Bool {
        fatalError("TODO: Implement JOIN with expectations, check title")
    }

    // MARK: - Private Helpers (Multi-Table JSON Assembly)

    /// Assemble GoalData from complex multi-table query row
    ///
    /// **Pattern**:
    /// 1. Parse measuresJson → [GoalData.MeasureTarget]
    /// 2. Parse valuesJson → [GoalData.ValueAlignment]
    /// 3. Parse termsJson → [GoalData.TermAssignment]
    /// 4. Flatten Goal + Expectation fields
    /// 5. Construct GoalData with all nested structs
    ///
    /// **Complexity**: Highest assembly logic in repository layer
    /// Each relationship has multiple fields to parse and validate
    ///
    /// TODO: Implement multi-step JSON parsing and assembly
    private func assembleGoalData(from row: GoalQueryRow) throws -> GoalData {
        fatalError("TODO: Parse 3 JSON arrays, flatten fields, assemble GoalData")
    }

    // TODO: Define GoalQueryRow struct (mirrors complex SQL result)
    private struct GoalQueryRow: Decodable, FetchableRecord, Sendable {
        // Goal fields
        let goalId: UUID           // Aliased to avoid conflict with Expectation.id
        let expectationId: UUID
        let startDate: Date?
        let targetDate: Date?
        let actionPlan: String?
        let expectedTermLength: Int?

        // Expectation fields (flattened)
        let expectationTitle: String           // Aliased: e.title as expectationTitle
        let expectationDescription: String?
        let expectationNotes: String?
        let expectationLogTime: Date
        let expectationType: String
        let expectationImportance: Int
        let expectationUrgency: Int

        // JSON aggregated relationships
        let measuresJson: String      // [MeasureTarget] as JSON
        let valuesJson: String        // [ValueAlignment] as JSON
        let termsJson: String         // [TermAssignment] as JSON
    }
}

// MARK: - Sendable Conformance

// GoalRepository_v3 is Sendable because:
// - Inherits from BaseRepository (already Sendable)
// - No additional mutable state
// - Safe to pass between actor boundaries
extension GoalRepository_v3: @unchecked Sendable {}

// =============================================================================
// IMPLEMENTATION CHECKLIST
// =============================================================================
//
// [ ] Define GoalQueryRow struct with aliased columns + JSON fields
// [ ] Write multi-table SQL (goals + expectations + measures + values + terms)
// [ ] Implement JSON aggregation for 3 relationship types
// [ ] Implement assembleGoalData(from:) - parse 3 JSON arrays, flatten fields
// [ ] Override fetchAll() - execute complex SQL, map rows to GoalData
// [ ] Override exists(_:) - simple ID check on goals table
// [ ] Override fetchForExport(from:to:) - add WHERE e.logTime BETWEEN ? AND ?
// [ ] Override fetch(limit:offset:) - add LIMIT/OFFSET (RECOMMENDED for performance)
// [ ] Override fetchRecent(limit:) - ORDER BY e.logTime DESC LIMIT ?
// [ ] Implement fetchAlignedWith(valueId:) - JOIN goalRelevances
// [ ] Implement fetchInTerm(termId:) - JOIN termGoalAssignments
// [ ] Implement fetchByMeasure(measureId:) - JOIN expectationMeasures
// [ ] Implement fetchActive(asOf:) - date range filtering on start/target dates
// [ ] Implement fetchByPriority(minimumImportance:minimumUrgency:) - quadrant filtering
// [ ] Implement totalProgress(for:) - SUM action contributions
// [ ] Implement countContributions(for:) - COUNT action contributions
// [ ] Implement exists(title:) - JOIN expectations, check title
// [ ] Test with GoalData.asDetails for backward compatibility
//
// =============================================================================
