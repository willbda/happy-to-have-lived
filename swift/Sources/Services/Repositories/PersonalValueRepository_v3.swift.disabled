//
// PersonalValueRepository_v3.swift
// Written by Claude Code on 2025-11-16
//
// PURPOSE:
// Repository for PersonalValue entities using canonical PersonalValueData type.
// Simpler than Action/Goal - fewer relationships, straightforward query pattern.
//
// DESIGN DECISIONS:
// - Extends BaseRepository<PersonalValueData> (no separate export type)
// - Uses #sql macro strategy (simpler than JSON aggregation)
// - Relationship data: alignedGoalIds array (1:many via goalRelevances table)
// - Inherits: error mapping, read/write wrappers, date filtering, pagination
// - Adds entity-specific: title uniqueness check, priority filtering
//
// INTERACTION WITH CORE:
// - BaseRepository: Provides read/write wrappers, error mapping, pagination helpers
// - QueryStrategies: Uses SQLMacroStrategy (simpler than JSON aggregation)
// - ExportSupport: Date filtering via buildDateFilter() helper
// - RepositoryProtocols: Conforms to Repository protocol (single DataType)
//

import Foundation
import Models
import SQLiteData
import GRDB

/// Repository for managing PersonalValue entities
///
/// **Architecture Pattern**:
/// ```
/// PersonalValueRepository_v3 → BaseRepository<PersonalValueData> → Repository protocol
///                            ↓
///                     SQLMacroStrategy (#sql for simple queries)
/// ```
///
/// **Simplicity vs Action/Goal**:
/// - PersonalValue has ONE relationship (aligned goals)
/// - No nested structures like measurements/contributions
/// - Can use simpler #sql macro instead of JSON aggregation
///
/// **What BaseRepository Provides**:
/// - ✅ Error mapping (mapDatabaseError)
/// - ✅ Read/write wrappers with automatic error handling
/// - ✅ Date filtering helpers (buildDateFilter)
/// - ✅ Pagination (fetch(limit:offset:), fetchRecent(limit:))
///
/// **What This Repository Adds**:
/// - Title uniqueness checks (exists(title:))
/// - Priority-based filtering (fetchByPriority)
/// - Value level filtering (fetchByValueLevel)
/// - Alignment relationship loading (alignedGoalIds from goalRelevances)
///
public final class PersonalValueRepository_v3: BaseRepository<PersonalValueData> {
    // MARK: - Required Overrides

    /// Fetch all personal values with aligned goal IDs
    ///
    /// **Implementation Strategy**: #sql macro with LEFT JOIN
    /// - Join personalValues with goalRelevances to get aligned goal IDs
    /// - Group by value ID to collect goal IDs into array
    /// - Returns PersonalValueData (canonical type)
    ///
    /// **SQL Pattern**:
    /// ```sql
    /// SELECT pv.*,
    ///   COALESCE(
    ///     (SELECT json_group_array(goalId) FROM goalRelevances WHERE valueId = pv.id),
    ///     '[]'
    ///   ) as alignedGoalIdsJson
    /// FROM personalValues pv
    /// ORDER BY priority DESC
    /// ```
    ///
    /// **Simpler than Action**: Only one relationship to load (alignedGoalIds)
    /// No nested measurements or contributions.
    ///
    /// TODO: Implement query with aligned goal IDs
    public override func fetchAll() async throws -> [PersonalValueData] {
        fatalError("TODO: Implement #sql query with aligned goals")
        // try await read { db in
        //     let rows = try ValueQueryRow.fetchAll(db, sql: sqlWithGoalIds)
        //     return rows.map { row in
        //         assembleValueData(from: row)
        //     }
        // }
    }

    /// Check if personal value exists by ID
    ///
    /// **Implementation**: Simple SELECT COUNT query
    /// Uses inherited `read` wrapper for automatic error mapping.
    ///
    /// TODO: Implement using #sql or raw SQL
    public override func exists(_ id: UUID) async throws -> Bool {
        fatalError("TODO: Implement exists check")
        // try await read { db in
        //     try PersonalValue.filter(id: id).fetchCount(db) > 0
        // }
    }

    /// Fetch values with optional date filtering (for export)
    ///
    /// **Implementation**: Same as fetchAll() + WHERE clause
    /// Uses inherited `buildDateFilter` helper for SQL generation.
    ///
    /// TODO: Implement with date filter injection
    public override func fetchForExport(from startDate: Date?, to endDate: Date?) async throws -> [PersonalValueData] {
        fatalError("TODO: Implement export with date filter")
        // Same query as fetchAll(), but with WHERE logTime BETWEEN ? AND ?
    }

    // MARK: - Pagination Overrides (Optional)

    /// Fetch paginated values (override for SQL LIMIT/OFFSET)
    ///
    /// **Optimization**: Add LIMIT/OFFSET to SQL query instead of in-memory slicing
    ///
    /// TODO: Implement SQL-level pagination
    public override func fetch(limit: Int, offset: Int = 0) async throws -> [PersonalValueData] {
        fatalError("TODO: Add LIMIT/OFFSET to SQL")
    }

    /// Fetch most recent values (override for SQL ORDER BY + LIMIT)
    ///
    /// **Note**: For values, "recent" = logTime DESC
    /// Different from priority sorting (which is more common for values)
    ///
    /// TODO: Implement with SQL sorting
    public override func fetchRecent(limit: Int) async throws -> [PersonalValueData] {
        fatalError("TODO: Add ORDER BY logTime DESC LIMIT ?")
    }

    // MARK: - Entity-Specific Queries

    /// Check if value with title already exists (case-insensitive)
    ///
    /// **Use Case**: Prevent duplicate "Family" values
    /// **Implementation**: SELECT COUNT WHERE LOWER(title) = LOWER(?)
    ///
    /// **Note**: This is simpler than Action's compound check (title+date)
    /// Values only need title uniqueness.
    ///
    /// TODO: Implement title uniqueness check
    public func exists(title: String) async throws -> Bool {
        fatalError("TODO: Implement case-insensitive title check")
    }

    /// Fetch values by priority threshold
    ///
    /// **Use Case**: "Show all values with priority >= 8"
    /// **Implementation**: WHERE priority >= ? ORDER BY priority DESC
    ///
    /// TODO: Implement priority filtering
    public func fetchByPriority(minimumPriority: Int) async throws -> [PersonalValueData] {
        fatalError("TODO: Implement priority filtering")
    }

    /// Fetch values by value level
    ///
    /// **Use Case**: "Show only highest_order values" or "Show all life_area values"
    /// **Implementation**: WHERE valueLevel = ?
    ///
    /// **Value Levels**: general, major, highest_order, life_area
    ///
    /// TODO: Implement value level filtering
    public func fetchByValueLevel(_ level: String) async throws -> [PersonalValueData] {
        fatalError("TODO: Implement value level filtering")
    }

    /// Fetch values aligned with a specific goal
    ///
    /// **Use Case**: "What values does this goal serve?"
    /// **Implementation**: JOIN with goalRelevances WHERE goalId = ?
    ///
    /// **Note**: This is the inverse of "what goals align with this value"
    /// (which is stored in PersonalValueData.alignedGoalIds)
    ///
    /// TODO: Implement goal alignment query
    public func fetchAlignedWith(goalId: UUID) async throws -> [PersonalValueData] {
        fatalError("TODO: Implement JOIN with goalRelevances")
    }

    /// Fetch values by life domain
    ///
    /// **Use Case**: "Show all health-related values"
    /// **Implementation**: WHERE lifeDomain = ?
    ///
    /// **Note**: lifeDomain is optional (can be NULL)
    ///
    /// TODO: Implement life domain filtering
    public func fetchByLifeDomain(_ domain: String) async throws -> [PersonalValueData] {
        fatalError("TODO: Implement life domain filtering")
    }

    // MARK: - Private Helpers

    /// Assemble PersonalValueData from query row
    ///
    /// **Pattern**: Parse alignedGoalIdsJson array (if using JSON aggregation)
    /// OR collect aligned goal IDs from grouped rows (if using GROUP BY)
    ///
    /// **Simpler than ActionData**: Only one relationship to assemble
    ///
    /// TODO: Implement assembly from row
    private func assembleValueData(from row: ValueQueryRow) -> PersonalValueData {
        fatalError("TODO: Parse aligned goal IDs and assemble PersonalValueData")
    }

    // TODO: Define ValueQueryRow struct (mirrors SQL query result)
    private struct ValueQueryRow: Decodable, FetchableRecord, Sendable {
        // PersonalValue fields
        let id: UUID
        let title: String
        let detailedDescription: String?
        let freeformNotes: String?
        let logTime: Date
        let priority: Int
        let valueLevel: String
        let lifeDomain: String?
        let alignmentGuidance: String?

        // Relationship data (JSON aggregated)
        let alignedGoalIdsJson: String  // JSON array of UUID strings
    }
}

// MARK: - Sendable Conformance

// PersonalValueRepository_v3 is Sendable because:
// - Inherits from BaseRepository (already Sendable)
// - No additional mutable state
// - Safe to pass between actor boundaries
extension PersonalValueRepository_v3: @unchecked Sendable {}

// =============================================================================
// IMPLEMENTATION CHECKLIST
// =============================================================================
//
// [ ] Define ValueQueryRow struct with alignedGoalIdsJson column
// [ ] Write SQL query with aligned goal IDs (json_group_array or GROUP BY)
// [ ] Implement assembleValueData(from:) - parse JSON array of goal IDs
// [ ] Override fetchAll() - execute SQL, map rows to PersonalValueData
// [ ] Override exists(_:) - simple ID check
// [ ] Override fetchForExport(from:to:) - add WHERE clause for date filter
// [ ] Override fetch(limit:offset:) - add LIMIT/OFFSET to SQL (optional)
// [ ] Override fetchRecent(limit:) - add ORDER BY + LIMIT to SQL (optional)
// [ ] Implement exists(title:) - case-insensitive title uniqueness check
// [ ] Implement fetchByPriority(minimumPriority:) - filter by priority threshold
// [ ] Implement fetchByValueLevel(_:) - filter by value level enum
// [ ] Implement fetchAlignedWith(goalId:) - JOIN with goalRelevances
// [ ] Implement fetchByLifeDomain(_:) - filter by life domain
// [ ] Test with PersonalValueData.asValue for backward compatibility
//
// =============================================================================
